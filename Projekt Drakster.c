#pragma config(Sensor, S1,     TouchRight,     sensorEV3_Touch)
#pragma config(Sensor, S2,     TouchLeft,      sensorEV3_Touch)
#pragma config(Sensor, S3,     IRDistance1,    sensorEV3_IRSensor)
#pragma config(Motor,  motorB,          motorLeft,     tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorC,          motorRight,    tmotorEV3_Large, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//==========================================================================================================================================

task Right()
{
	while (true)
	{
		// Pokud senzor detekuje vstup, aktivuje pravý motor a vytvoYí cervené podsvícení.
		if (SensorValue[TouchRight])
		{
			displayCenteredBigTextLine(5, "Aktivni!");
			setLEDColor(ledRed);
			motor[motorRight] = 100;
		}
		// Pokud senzor nedetekuje vstup, deaktivuje pravý motor a vyvoYí zelené podsvícení.
		else
		{
			displayCenteredBigTextLine(5, "Neaktivni!");
			setLEDColor(ledGreen);
			motor[motorRight] = 0;
		}
		//Nastavení rychlosti odezvy mezi spustním a vypnutím pravého motoru.
		sleep(1);
	}
  return;
}

//==========================================================================================================================================
//==========================================================================================================================================

task Left()
{
 	while (true)
	{
		// Pokud senzor detekuje vstup, aktivuje levý motor a vytvoYí cervené podsvícení.
		if (SensorValue[TouchLeft])
		{
			displayCenteredBigTextLine(5, "Aktivni!");
			setLEDColor(ledRed);
			motor[motorLeft] = 100;
		}
		// Pokud senzor nedetekuje vstup, deaktivuje levý motor a vyvoYí zelené podsvícení.
		else
		{
			displayCenteredBigTextLine(5, "Neaktivni!");
			setLEDColor(ledGreen);
			motor[motorLeft] = 0;
		}
		//Nastavení rychlosti odezvy mezi spustním a vypnutím levého motoru.
		sleep(1);
	}
  return;
}
//==========================================================================================================================================
//==========================================================================================================================================

task Distance()
{
 	int distanceToMaintain = 300;

	int currentDistance = 0;

	while(true)
	{
		// Read the sensor
		currentDistance = SensorValue[IRDistance1];

		displayCenteredBigTextLine(8, "Dist: %d", currentDistance);

		// We're too close, move backwards
		if ((distanceToMaintain - currentDistance) > 2)
		{
			motor[motorLeft] = -100;
			motor[motorRight] = -100;
			wait1Msec(2500);
			motor[motorLeft] = 0;
			motor[motorRight] = 0;
		}

		//Loop to monitor value in Sensor debugger window
		sleep(1);
	}
  return;
}

//==========================================================================================================================================
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

task main()
{
  startTask(Right);                             // Start Task TOne.
  startTask(Left);                             // Start Task TTwo.
	startTask(Distance);
  while(true)
  {
    wait1Msec(300);                                 // Allow for a short wait, freeing up the CPU for other tasks.

    displayCenteredBigTextLine(0, "Uspesne spusten");     // Display that Main is running.
    displayCenteredBigTextLine(3, "Motory:");
  }
  return;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
